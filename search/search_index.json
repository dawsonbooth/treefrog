{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"treefrog \u00b6 Description \u00b6 Organize the Slippi game files in your filesystem according to their attributes. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 python -m pip install treefrog Usage \u00b6 Module \u00b6 Currently, the package supports organizing the files according to a supplied ordering of parsers, flattening the files against the supplied root folder, and renaming all the files according to their attributes. These may be accomplished programmatically with the use of the Tree class or through the command-line interface. Organize \u00b6 The organize method serves the purpose of moving each game file found (deeply or otherwise) under the root folder to its proper location according to the supplied ordering of parsers. If no ordering is given, then treefrog will use its default. Here is a simple example of calling this method: 1 2 3 4 5 6 7 8 9 10 11 12 from treefrog import Tree from treefrog.parse.parsers import year , month , matchup , stage ordering = ( year , month , matchup , stage ) # An iterable of the desired levels of the hierarchy with Tree ( \"slp/\" , show_progress = True ) as tree : tree . organize ( ordering ) # Organize the files into subfolders according to the supplied attributes Feel free to provide your own logic for formatting the names of the folders at a particular level with a corresponding iterable of functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from treefrog import Tree from treefrog.parse.parsers import year , month , stage from treefrog.parse.utils import character_name , most_used_character , opponent , user def ordered_matchup ( game ): p1 = user ( game , \"DTB#566\" ) p2 = opponent ( game , \"DTB#566\" ) return f \" { character_name ( most_used_character ( p1 )) } vs { character_name ( most_used_character ( p2 )) } \" ordering = ( year , month , lambda game : opponent ( game , \"DTB#566\" ) . netplay . code , ordered_matchup , stage ) with Tree ( \"slp/\" , show_progress = True ) as tree : tree . organize ( ordering ) Any custom parser you provide will need to be a Callable that takes in a Game instance and returns a str . Further, you can use cascading methods to simplify your programming. Each of the methods organize , flatten , and rename will return a reference to the instance object on which it was called. Something like this: tree.organize().rename() will both organize and rename the game files. Flatten \u00b6 The flatten method serves the simple purpose of moving each game file found (deeply or otherwise) under the root folder back to the root folder itself. Here's an example of what calling this method may look like: 1 2 3 4 from treefrog import Tree tree = Tree ( \"slp/\" ) tree . flatten () . resolve () Note that you do not have to use Tree with a context manager. If you do not use the with keyword as in the first couple of examples, you will need to end your operations with a call to the resolve method in order to see the changes reflected in your filesystem. Rename \u00b6 The rename method simply renames each game file according to its attributes. Without a rename function supplied, treefrog will use the default_filename function found in the treefrog.rename module. Alternatively, you may provide your own rename function as shown below: 1 2 3 4 5 6 7 8 9 10 from treefrog import Tree from treefrog.parse.parsers import stage , timestamp from treefrog.parse.utils import character_name , characters def create_filename ( game : Game ): p1 , p2 = tuple ( characters ( game )) return f \" { timestamp ( game ) } - { character_name ( p1 ) } vs { character_name ( p2 ) } - { stage ( game ) } .slp\" with Tree ( \"slp/\" ) as tree : tree . rename ( create_filename = create_filename ) Command-Line \u00b6 This is also command-line program, and can be executed as follows: 1 python -m treefrog [-h] [-g GLOB] [-c NETPLAY_CODE] [-p] [-d] [-o | -f] [-r] root_folder Options: Argument Description root_folder Slippi folder root path -h, --help show this help message and exit -g GLOB, --glob GLOB The glob pattern to search with -c NETPLAY_CODE, --netplay-code NETPLAY_CODE Netplay code (e.g. DTB#566) -p, --show-progress Whether to show a progress bar -d, --default-rename Whether to restore the filenames to their defaults -o, --organize Whether to organize the folder hierarchy -f, --flatten Whether to flatten your Slippi game files to a shared parent folder -r, --rename Whether to rename the files according to their features For example, the following command will organize all the game files under the slp directory with a progress bar. 1 python -m treefrog \"slp\" -c \"DTB#566\" -op Feel free to check out the docs for more information. License \u00b6 This software is released under the terms of MIT license .","title":"Overview"},{"location":"#treefrog","text":"","title":"treefrog"},{"location":"#description","text":"Organize the Slippi game files in your filesystem according to their attributes.","title":"Description"},{"location":"#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 python -m pip install treefrog","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#module","text":"Currently, the package supports organizing the files according to a supplied ordering of parsers, flattening the files against the supplied root folder, and renaming all the files according to their attributes. These may be accomplished programmatically with the use of the Tree class or through the command-line interface.","title":"Module"},{"location":"#organize","text":"The organize method serves the purpose of moving each game file found (deeply or otherwise) under the root folder to its proper location according to the supplied ordering of parsers. If no ordering is given, then treefrog will use its default. Here is a simple example of calling this method: 1 2 3 4 5 6 7 8 9 10 11 12 from treefrog import Tree from treefrog.parse.parsers import year , month , matchup , stage ordering = ( year , month , matchup , stage ) # An iterable of the desired levels of the hierarchy with Tree ( \"slp/\" , show_progress = True ) as tree : tree . organize ( ordering ) # Organize the files into subfolders according to the supplied attributes Feel free to provide your own logic for formatting the names of the folders at a particular level with a corresponding iterable of functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from treefrog import Tree from treefrog.parse.parsers import year , month , stage from treefrog.parse.utils import character_name , most_used_character , opponent , user def ordered_matchup ( game ): p1 = user ( game , \"DTB#566\" ) p2 = opponent ( game , \"DTB#566\" ) return f \" { character_name ( most_used_character ( p1 )) } vs { character_name ( most_used_character ( p2 )) } \" ordering = ( year , month , lambda game : opponent ( game , \"DTB#566\" ) . netplay . code , ordered_matchup , stage ) with Tree ( \"slp/\" , show_progress = True ) as tree : tree . organize ( ordering ) Any custom parser you provide will need to be a Callable that takes in a Game instance and returns a str . Further, you can use cascading methods to simplify your programming. Each of the methods organize , flatten , and rename will return a reference to the instance object on which it was called. Something like this: tree.organize().rename() will both organize and rename the game files.","title":"Organize"},{"location":"#flatten","text":"The flatten method serves the simple purpose of moving each game file found (deeply or otherwise) under the root folder back to the root folder itself. Here's an example of what calling this method may look like: 1 2 3 4 from treefrog import Tree tree = Tree ( \"slp/\" ) tree . flatten () . resolve () Note that you do not have to use Tree with a context manager. If you do not use the with keyword as in the first couple of examples, you will need to end your operations with a call to the resolve method in order to see the changes reflected in your filesystem.","title":"Flatten"},{"location":"#rename","text":"The rename method simply renames each game file according to its attributes. Without a rename function supplied, treefrog will use the default_filename function found in the treefrog.rename module. Alternatively, you may provide your own rename function as shown below: 1 2 3 4 5 6 7 8 9 10 from treefrog import Tree from treefrog.parse.parsers import stage , timestamp from treefrog.parse.utils import character_name , characters def create_filename ( game : Game ): p1 , p2 = tuple ( characters ( game )) return f \" { timestamp ( game ) } - { character_name ( p1 ) } vs { character_name ( p2 ) } - { stage ( game ) } .slp\" with Tree ( \"slp/\" ) as tree : tree . rename ( create_filename = create_filename )","title":"Rename"},{"location":"#command-line","text":"This is also command-line program, and can be executed as follows: 1 python -m treefrog [-h] [-g GLOB] [-c NETPLAY_CODE] [-p] [-d] [-o | -f] [-r] root_folder Options: Argument Description root_folder Slippi folder root path -h, --help show this help message and exit -g GLOB, --glob GLOB The glob pattern to search with -c NETPLAY_CODE, --netplay-code NETPLAY_CODE Netplay code (e.g. DTB#566) -p, --show-progress Whether to show a progress bar -d, --default-rename Whether to restore the filenames to their defaults -o, --organize Whether to organize the folder hierarchy -f, --flatten Whether to flatten your Slippi game files to a shared parent folder -r, --rename Whether to rename the files according to their features For example, the following command will organize all the game files under the slp directory with a progress bar. 1 python -m treefrog \"slp\" -c \"DTB#566\" -op Feel free to check out the docs for more information.","title":"Command-Line"},{"location":"#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"reference/treefrog/","text":"Module treefrog \u00b6 None None View Source from .tree import Tree __all__ = ( \"Tree\" ,) Sub-modules \u00b6 treefrog.cli treefrog.organize treefrog.parse treefrog.rename treefrog.tree Classes \u00b6 Tree \u00b6 1 2 3 4 5 class Tree ( root_folder : 'Union[str, os.PathLike[str]]' , glob : 'str' = '**/*.slp' , show_progress : 'bool' = False ) View Source class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path, ... ] destinations : List [ Path ] operations : Dict [ str, Callable[[Path, Game ] , Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str, os.PathLike[str ] ] , glob : str = \"**/*.slp\" , show_progress : bool = False ) : self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Methods \u00b6 flatten \u00b6 1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self organize \u00b6 1 2 3 4 def organize ( self , ordering : 'Ordering' = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> 'Tree' View Source def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self rename \u00b6 1 2 3 4 def rename ( self , create_filename =< function create_filename at 0x7f4e1b5cd310 > ) -> 'Tree' View Source def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self reset \u00b6 1 2 3 def reset ( self ) -> 'Tree' View Source def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self resolve \u00b6 1 2 3 def resolve ( self ) -> 'Tree' View Source def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self","title":"Index"},{"location":"reference/treefrog/#module-treefrog","text":"None None View Source from .tree import Tree __all__ = ( \"Tree\" ,)","title":"Module treefrog"},{"location":"reference/treefrog/#sub-modules","text":"treefrog.cli treefrog.organize treefrog.parse treefrog.rename treefrog.tree","title":"Sub-modules"},{"location":"reference/treefrog/#classes","text":"","title":"Classes"},{"location":"reference/treefrog/#tree","text":"1 2 3 4 5 class Tree ( root_folder : 'Union[str, os.PathLike[str]]' , glob : 'str' = '**/*.slp' , show_progress : 'bool' = False ) View Source class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path, ... ] destinations : List [ Path ] operations : Dict [ str, Callable[[Path, Game ] , Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str, os.PathLike[str ] ] , glob : str = \"**/*.slp\" , show_progress : bool = False ) : self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Tree"},{"location":"reference/treefrog/#methods","text":"","title":"Methods"},{"location":"reference/treefrog/#flatten","text":"1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self","title":"flatten"},{"location":"reference/treefrog/#organize","text":"1 2 3 4 def organize ( self , ordering : 'Ordering' = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> 'Tree' View Source def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self","title":"organize"},{"location":"reference/treefrog/#rename","text":"1 2 3 4 def rename ( self , create_filename =< function create_filename at 0x7f4e1b5cd310 > ) -> 'Tree' View Source def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self","title":"rename"},{"location":"reference/treefrog/#reset","text":"1 2 3 def reset ( self ) -> 'Tree' View Source def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self","title":"reset"},{"location":"reference/treefrog/#resolve","text":"1 2 3 def resolve ( self ) -> 'Tree' View Source def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self","title":"resolve"},{"location":"reference/treefrog/cli/","text":"Module treefrog.cli \u00b6 None None View Source from pathlib import Path from typing import Any , Mapping , Sequence , TypedDict from .parse.parsers import month , stage , year from .parse.utils import character_name , most_used_character , opponent , user from .rename import default_filename from .tree import Tree class CLIArgument ( TypedDict ): name_or_flags : Sequence [ str ] kwargs : Mapping [ str , Any ] def organize ( tree : Tree , args ): if args . netplay_code : def opponent_netplay_code ( game ): return opponent ( game , args . netplay_code ) . netplay . code def ordered_matchup ( game ): p1 = user ( game , args . netplay_code ) p2 = opponent ( game , args . netplay_code ) return f \" { character_name ( most_used_character ( p1 )) } vs { character_name ( most_used_character ( p2 )) } \" ordering = ( year , month , opponent_netplay_code , ordered_matchup , stage ) tree . organize ( ordering = ordering ) else : tree . organize () def flatten ( tree : Tree , args ): tree . flatten () def rename ( tree : Tree , args ): if args . default_rename : tree . rename ( create_filename = default_filename ) else : tree . rename () root_folder : CLIArgument = { \"name_or_flags\" : [ \"root_folder\" ], \"kwargs\" : { \"type\" : Path , \"help\" : \"Slippi folder root path\" }, } glob : CLIArgument = { \"name_or_flags\" : [ \"-g\" , \"--glob\" ], \"kwargs\" : { \"type\" : str , \"default\" : \"**/*.slp\" , \"help\" : \"The glob pattern to search with\" }, } show_progress : CLIArgument = { \"name_or_flags\" : [ \"-p\" , \"--show-progress\" ], \"kwargs\" : { \"action\" : \"store_true\" , \"help\" : \"Whether to show a progress bar\" }, } netplay_code : CLIArgument = { \"name_or_flags\" : [ \"-c\" , \"--netplay-code\" ], \"kwargs\" : { \"type\" : str , \"help\" : \"Netplay code (e.g. DTB#566)\" }, } default_rename : CLIArgument = { \"name_or_flags\" : [ \"-d\" , \"--default-rename\" ], \"kwargs\" : { \"action\" : \"store_true\" , \"help\" : \"Whether to restore the filenames to their defaults\" }, } Variables \u00b6 1 default_rename 1 glob 1 netplay_code 1 root_folder 1 show_progress Functions \u00b6 flatten \u00b6 1 2 3 4 def flatten ( tree : treefrog . tree . Tree , args ) View Source def flatten(tree: Tree, args): tree.flatten() organize \u00b6 1 2 3 4 def organize ( tree : treefrog . tree . Tree , args ) View Source def organize ( tree : Tree , args ) : if args . netplay_code : def opponent_netplay_code ( game ) : return opponent ( game , args . netplay_code ) . netplay . code def ordered_matchup ( game ) : p1 = user ( game , args . netplay_code ) p2 = opponent ( game , args . netplay_code ) return f \" {character_name(most_used_character(p1))} vs {character_name(most_used_character(p2))} \" ordering = ( year , month , opponent_netplay_code , ordered_matchup , stage ) tree . organize ( ordering = ordering ) else : tree . organize () rename \u00b6 1 2 3 4 def rename ( tree : treefrog . tree . Tree , args ) View Source def rename ( tree : Tree , args ) : if args . default_rename : tree . rename ( create_filename = default_filename ) else : tree . rename () Classes \u00b6 CLIArgument \u00b6 1 2 3 4 5 class CLIArgument ( / , * args , ** kwargs ) View Source class CLIArgument ( TypedDict ) : name_or_flags : Sequence [ str ] kwargs : Mapping [ str, Any ] Ancestors (in MRO) \u00b6 builtins.dict Methods \u00b6 clear \u00b6 1 2 3 def clear ( ... ) D.clear() -> None. Remove all items from D. copy \u00b6 1 2 3 def copy ( ... ) D.copy() -> a shallow copy of D fromkeys \u00b6 1 2 3 4 5 def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get \u00b6 1 2 3 4 5 6 def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items \u00b6 1 2 3 def items ( ... ) D.items() -> a set-like object providing a view on D's items keys \u00b6 1 2 3 def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 1 2 3 def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised popitem \u00b6 1 2 3 4 def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault \u00b6 1 2 3 4 5 6 def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update \u00b6 1 2 3 def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values \u00b6 1 2 3 def values ( ... ) D.values() -> an object providing a view on D's values","title":"CLI"},{"location":"reference/treefrog/cli/#module-treefrogcli","text":"None None View Source from pathlib import Path from typing import Any , Mapping , Sequence , TypedDict from .parse.parsers import month , stage , year from .parse.utils import character_name , most_used_character , opponent , user from .rename import default_filename from .tree import Tree class CLIArgument ( TypedDict ): name_or_flags : Sequence [ str ] kwargs : Mapping [ str , Any ] def organize ( tree : Tree , args ): if args . netplay_code : def opponent_netplay_code ( game ): return opponent ( game , args . netplay_code ) . netplay . code def ordered_matchup ( game ): p1 = user ( game , args . netplay_code ) p2 = opponent ( game , args . netplay_code ) return f \" { character_name ( most_used_character ( p1 )) } vs { character_name ( most_used_character ( p2 )) } \" ordering = ( year , month , opponent_netplay_code , ordered_matchup , stage ) tree . organize ( ordering = ordering ) else : tree . organize () def flatten ( tree : Tree , args ): tree . flatten () def rename ( tree : Tree , args ): if args . default_rename : tree . rename ( create_filename = default_filename ) else : tree . rename () root_folder : CLIArgument = { \"name_or_flags\" : [ \"root_folder\" ], \"kwargs\" : { \"type\" : Path , \"help\" : \"Slippi folder root path\" }, } glob : CLIArgument = { \"name_or_flags\" : [ \"-g\" , \"--glob\" ], \"kwargs\" : { \"type\" : str , \"default\" : \"**/*.slp\" , \"help\" : \"The glob pattern to search with\" }, } show_progress : CLIArgument = { \"name_or_flags\" : [ \"-p\" , \"--show-progress\" ], \"kwargs\" : { \"action\" : \"store_true\" , \"help\" : \"Whether to show a progress bar\" }, } netplay_code : CLIArgument = { \"name_or_flags\" : [ \"-c\" , \"--netplay-code\" ], \"kwargs\" : { \"type\" : str , \"help\" : \"Netplay code (e.g. DTB#566)\" }, } default_rename : CLIArgument = { \"name_or_flags\" : [ \"-d\" , \"--default-rename\" ], \"kwargs\" : { \"action\" : \"store_true\" , \"help\" : \"Whether to restore the filenames to their defaults\" }, }","title":"Module treefrog.cli"},{"location":"reference/treefrog/cli/#variables","text":"1 default_rename 1 glob 1 netplay_code 1 root_folder 1 show_progress","title":"Variables"},{"location":"reference/treefrog/cli/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/cli/#flatten","text":"1 2 3 4 def flatten ( tree : treefrog . tree . Tree , args ) View Source def flatten(tree: Tree, args): tree.flatten()","title":"flatten"},{"location":"reference/treefrog/cli/#organize","text":"1 2 3 4 def organize ( tree : treefrog . tree . Tree , args ) View Source def organize ( tree : Tree , args ) : if args . netplay_code : def opponent_netplay_code ( game ) : return opponent ( game , args . netplay_code ) . netplay . code def ordered_matchup ( game ) : p1 = user ( game , args . netplay_code ) p2 = opponent ( game , args . netplay_code ) return f \" {character_name(most_used_character(p1))} vs {character_name(most_used_character(p2))} \" ordering = ( year , month , opponent_netplay_code , ordered_matchup , stage ) tree . organize ( ordering = ordering ) else : tree . organize ()","title":"organize"},{"location":"reference/treefrog/cli/#rename","text":"1 2 3 4 def rename ( tree : treefrog . tree . Tree , args ) View Source def rename ( tree : Tree , args ) : if args . default_rename : tree . rename ( create_filename = default_filename ) else : tree . rename ()","title":"rename"},{"location":"reference/treefrog/cli/#classes","text":"","title":"Classes"},{"location":"reference/treefrog/cli/#cliargument","text":"1 2 3 4 5 class CLIArgument ( / , * args , ** kwargs ) View Source class CLIArgument ( TypedDict ) : name_or_flags : Sequence [ str ] kwargs : Mapping [ str, Any ]","title":"CLIArgument"},{"location":"reference/treefrog/cli/#ancestors-in-mro","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"reference/treefrog/cli/#methods","text":"","title":"Methods"},{"location":"reference/treefrog/cli/#clear","text":"1 2 3 def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"reference/treefrog/cli/#copy","text":"1 2 3 def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"reference/treefrog/cli/#fromkeys","text":"1 2 3 4 5 def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"reference/treefrog/cli/#get","text":"1 2 3 4 5 6 def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"reference/treefrog/cli/#items","text":"1 2 3 def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"reference/treefrog/cli/#keys","text":"1 2 3 def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"reference/treefrog/cli/#pop","text":"1 2 3 def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised","title":"pop"},{"location":"reference/treefrog/cli/#popitem","text":"1 2 3 4 def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"reference/treefrog/cli/#setdefault","text":"1 2 3 4 5 6 def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"reference/treefrog/cli/#update","text":"1 2 3 def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"reference/treefrog/cli/#values","text":"1 2 3 def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"reference/treefrog/organize/","text":"Module treefrog.organize \u00b6 None None View Source from pathlib import Path from typing import Sequence from slippi.game import Game from ..parse import Parser from ..parse.parsers import matchup , month , stage , year Ordering = Sequence [ Parser ] default_ordering = ( year , month , matchup , stage ) def build_parent ( game : Game , ordering : Ordering = default_ordering ) -> Path : parent = Path () for parser in ordering : parent /= str ( parser ( game )) return parent Variables \u00b6 1 Ordering 1 default_ordering Functions \u00b6 build_parent \u00b6 1 2 3 4 def build_parent ( game : slippi . game . Game , ordering : Sequence [ Callable [[ slippi . game . Game ], str ]] = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> pathlib . Path View Source def build_parent ( game : Game , ordering : Ordering = default_ordering ) -> Path : parent = Path () for parser in ordering : parent /= str ( parser ( game )) return parent","title":"Organize"},{"location":"reference/treefrog/organize/#module-treefrogorganize","text":"None None View Source from pathlib import Path from typing import Sequence from slippi.game import Game from ..parse import Parser from ..parse.parsers import matchup , month , stage , year Ordering = Sequence [ Parser ] default_ordering = ( year , month , matchup , stage ) def build_parent ( game : Game , ordering : Ordering = default_ordering ) -> Path : parent = Path () for parser in ordering : parent /= str ( parser ( game )) return parent","title":"Module treefrog.organize"},{"location":"reference/treefrog/organize/#variables","text":"1 Ordering 1 default_ordering","title":"Variables"},{"location":"reference/treefrog/organize/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/organize/#build_parent","text":"1 2 3 4 def build_parent ( game : slippi . game . Game , ordering : Sequence [ Callable [[ slippi . game . Game ], str ]] = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> pathlib . Path View Source def build_parent ( game : Game , ordering : Ordering = default_ordering ) -> Path : parent = Path () for parser in ordering : parent /= str ( parser ( game )) return parent","title":"build_parent"},{"location":"reference/treefrog/rename/","text":"Module treefrog.rename \u00b6 None None View Source from slippi import Game from ..parse.parsers import stage , timestamp from ..parse.utils import character_name , characters def default_filename ( game : Game ) -> str : return f \"Game_ { timestamp ( game ) } .slp\" def create_filename ( game : Game ) -> str : p1 , p2 = tuple ( characters ( game )) return f \" { timestamp ( game ) } - { character_name ( p1 ) } vs { character_name ( p2 ) } - { stage ( game ) } .slp\" Functions \u00b6 create_filename \u00b6 1 2 3 def create_filename ( game : slippi . game . Game ) -> str View Source def create_filename ( game : Game ) -> str : p1 , p2 = tuple ( characters ( game )) return f \"{timestamp(game)} - {character_name(p1)} vs {character_name(p2)} - {stage(game)}.slp\" default_filename \u00b6 1 2 3 def default_filename ( game : slippi . game . Game ) -> str View Source def default_filename ( game : Game ) -> str : return f \"Game_{timestamp(game)}.slp\"","title":"Rename"},{"location":"reference/treefrog/rename/#module-treefrogrename","text":"None None View Source from slippi import Game from ..parse.parsers import stage , timestamp from ..parse.utils import character_name , characters def default_filename ( game : Game ) -> str : return f \"Game_ { timestamp ( game ) } .slp\" def create_filename ( game : Game ) -> str : p1 , p2 = tuple ( characters ( game )) return f \" { timestamp ( game ) } - { character_name ( p1 ) } vs { character_name ( p2 ) } - { stage ( game ) } .slp\"","title":"Module treefrog.rename"},{"location":"reference/treefrog/rename/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/rename/#create_filename","text":"1 2 3 def create_filename ( game : slippi . game . Game ) -> str View Source def create_filename ( game : Game ) -> str : p1 , p2 = tuple ( characters ( game )) return f \"{timestamp(game)} - {character_name(p1)} vs {character_name(p2)} - {stage(game)}.slp\"","title":"create_filename"},{"location":"reference/treefrog/rename/#default_filename","text":"1 2 3 def default_filename ( game : slippi . game . Game ) -> str View Source def default_filename ( game : Game ) -> str : return f \"Game_{timestamp(game)}.slp\"","title":"default_filename"},{"location":"reference/treefrog/tree/","text":"Module treefrog.tree \u00b6 None None View Source from __future__ import annotations import os import shutil from pathlib import Path from typing import Callable , Dict , List , Tuple , Union from slippi.game import Game from tqdm import tqdm from .organize import Ordering , build_parent , default_ordering from .parse.utils import games as parse_games from .rename import create_filename def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists (): os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists (): shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \" { stem } (1) { suffix } \" i = 1 while destination . exists (): destination = destination . parent / f \" { stem } ( { i } ) { suffix } \" i += 1 shutil . move ( str ( source ), str ( destination )) class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path , ... ] destinations : List [ Path ] operations : Dict [ str , Callable [[ Path , Game ], Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str , os . PathLike [ str ]], glob : str = \"**/*.slp\" , show_progress : bool = False ): self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ): try : for operation in self . operations . values (): self . destinations [ i ] = operation ( self . destinations [ i ], game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ): parents = list ( source . parents ) for parent in parents [ parents . index ( self . root ) :]: if parent not in processed_folders and len ([ f for f in parent . rglob ( \"*\" ) if not f . is_dir ()]) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Variables \u00b6 1 default_ordering Functions \u00b6 safe_move \u00b6 1 2 3 4 def safe_move ( source : 'Path' , destination : 'Path' ) -> 'None' View Source def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists () : os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists () : shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \"{stem} (1){suffix}\" i = 1 while destination . exists () : destination = destination . parent / f \"{stem} ({i}){suffix}\" i += 1 shutil . move ( str ( source ), str ( destination )) Classes \u00b6 Tree \u00b6 1 2 3 4 5 class Tree ( root_folder : 'Union[str, os.PathLike[str]]' , glob : 'str' = '**/*.slp' , show_progress : 'bool' = False ) View Source class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path, ... ] destinations : List [ Path ] operations : Dict [ str, Callable[[Path, Game ] , Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str, os.PathLike[str ] ] , glob : str = \"**/*.slp\" , show_progress : bool = False ) : self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Methods \u00b6 flatten \u00b6 1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self organize \u00b6 1 2 3 4 def organize ( self , ordering : 'Ordering' = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> 'Tree' View Source def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self rename \u00b6 1 2 3 4 def rename ( self , create_filename =< function create_filename at 0x7f4e1b5cd310 > ) -> 'Tree' View Source def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self reset \u00b6 1 2 3 def reset ( self ) -> 'Tree' View Source def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self resolve \u00b6 1 2 3 def resolve ( self ) -> 'Tree' View Source def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self","title":"Tree"},{"location":"reference/treefrog/tree/#module-treefrogtree","text":"None None View Source from __future__ import annotations import os import shutil from pathlib import Path from typing import Callable , Dict , List , Tuple , Union from slippi.game import Game from tqdm import tqdm from .organize import Ordering , build_parent , default_ordering from .parse.utils import games as parse_games from .rename import create_filename def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists (): os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists (): shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \" { stem } (1) { suffix } \" i = 1 while destination . exists (): destination = destination . parent / f \" { stem } ( { i } ) { suffix } \" i += 1 shutil . move ( str ( source ), str ( destination )) class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path , ... ] destinations : List [ Path ] operations : Dict [ str , Callable [[ Path , Game ], Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str , os . PathLike [ str ]], glob : str = \"**/*.slp\" , show_progress : bool = False ): self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ): try : for operation in self . operations . values (): self . destinations [ i ] = operation ( self . destinations [ i ], game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ): parents = list ( source . parents ) for parent in parents [ parents . index ( self . root ) :]: if parent not in processed_folders and len ([ f for f in parent . rglob ( \"*\" ) if not f . is_dir ()]) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Module treefrog.tree"},{"location":"reference/treefrog/tree/#variables","text":"1 default_ordering","title":"Variables"},{"location":"reference/treefrog/tree/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/tree/#safe_move","text":"1 2 3 4 def safe_move ( source : 'Path' , destination : 'Path' ) -> 'None' View Source def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists () : os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists () : shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \"{stem} (1){suffix}\" i = 1 while destination . exists () : destination = destination . parent / f \"{stem} ({i}){suffix}\" i += 1 shutil . move ( str ( source ), str ( destination ))","title":"safe_move"},{"location":"reference/treefrog/tree/#classes","text":"","title":"Classes"},{"location":"reference/treefrog/tree/#tree","text":"1 2 3 4 5 class Tree ( root_folder : 'Union[str, os.PathLike[str]]' , glob : 'str' = '**/*.slp' , show_progress : 'bool' = False ) View Source class Tree : root : Path glob : str show_progress : bool sources : Tuple [ Path, ... ] destinations : List [ Path ] operations : Dict [ str, Callable[[Path, Game ] , Path ]] should_resolve : bool def __init__ ( self , root_folder : Union [ str, os.PathLike[str ] ] , glob : str = \"**/*.slp\" , show_progress : bool = False ) : self . root = Path ( root_folder ) self . glob = glob self . show_progress = show_progress self . reset () def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self def __enter__ ( self ) -> Tree : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Tree"},{"location":"reference/treefrog/tree/#methods","text":"","title":"Methods"},{"location":"reference/treefrog/tree/#flatten","text":"1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root / path . name self . operations . pop ( \"organize\" , None ) return self","title":"flatten"},{"location":"reference/treefrog/tree/#organize","text":"1 2 3 4 def organize ( self , ordering : 'Ordering' = ( < function year at 0x7f4e1b5cbee0 > , < function month at 0x7f4e1b5cbf70 > , < function matchup at 0x7f4e1b59d430 > , < function stage at 0x7f4e1b5cbdc0 > ) ) -> 'Tree' View Source def organize ( self , ordering : Ordering = default_ordering ) -> Tree : self . operations [ \"organize\" ] = lambda path , game : self . root / build_parent ( game , ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self","title":"organize"},{"location":"reference/treefrog/tree/#rename","text":"1 2 3 4 def rename ( self , create_filename =< function create_filename at 0x7f4e1b5cd310 > ) -> 'Tree' View Source def rename ( self , create_filename = create_filename ) -> Tree : self . operations [ \"rename\" ] = lambda path , game : path . parent / create_filename ( game ) return self","title":"rename"},{"location":"reference/treefrog/tree/#reset","text":"1 2 3 def reset ( self ) -> 'Tree' View Source def reset ( self ) -> Tree : self . sources = tuple ( self . root . glob ( self . glob )) self . destinations = list ( self . sources ) self . operations = dict () return self","title":"reset"},{"location":"reference/treefrog/tree/#resolve","text":"1 2 3 def resolve ( self ) -> 'Tree' View Source def resolve ( self ) -> Tree : # Perform operations games = parse_games ( self . sources ) if self . show_progress : games = tqdm ( games , desc = \"Process games\" , total = len ( self . sources )) for i , game in enumerate ( games ) : try : for operation in self . operations . values () : self . destinations [ i ] = operation ( self . destinations [ i ] , game ) except Exception as e : self . destinations [ i ] = self . root / e . __class__ . __name__ / self . destinations [ i ] . name # Move files paths = zip ( self . sources , self . destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) # Remove empty source folders processed_folders = set () for source in tqdm ( self . sources ) : parents = list ( source . parents ) for parent in parents [ parents.index(self.root) : ] : if parent not in processed_folders and len ( [ f for f in parent.rglob(\"*\") if not f.is_dir() ] ) == 0 : shutil . rmtree ( parent ) processed_folders . add ( parent ) self . reset () return self","title":"resolve"},{"location":"reference/treefrog/parse/","text":"Module treefrog.parse \u00b6 None None View Source from .parsers import day , hour , matchup , minute , month , second , stage , timestamp , year from .utils import ParseError , Parser __all__ = ( \"matchup\" , \"stage\" , \"timestamp\" , \"year\" , \"month\" , \"day\" , \"hour\" , \"minute\" , \"second\" , \"Parser\" , \"ParseError\" , ) Sub-modules \u00b6 treefrog.parse.parsers treefrog.parse.utils Variables \u00b6 1 Parser Functions \u00b6 day \u00b6 1 2 3 def day ( game : 'Game' ) -> 'str' View Source def day ( game : Game ) -> str : return str ( game . metadata . date . day ) hour \u00b6 1 2 3 def hour ( game : 'Game' ) -> 'str' View Source def hour ( game : Game ) -> str : return str ( game . metadata . date . hour ) matchup \u00b6 1 2 3 def matchup ( game : 'Game' ) -> 'str' View Source def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \"{character_name(c1)} vs {character_name(c2)}\" minute \u00b6 1 2 3 def minute ( game : 'Game' ) -> 'str' View Source def minute ( game : Game ) -> str : return str ( game . metadata . date . minute ) month \u00b6 1 2 3 def month ( game : 'Game' ) -> 'str' View Source def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ] second \u00b6 1 2 3 def second ( game : 'Game' ) -> 'str' View Source def second ( game : Game ) -> str : return str ( game . metadata . date . second ) stage \u00b6 1 2 3 def stage ( game : 'Game' ) -> 'str' View Source def stage ( game : Game ) -> str : return stage_name ( game . start . stage ) timestamp \u00b6 1 2 3 def timestamp ( game : 'Game' ) -> 'str' View Source def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ). astimezone ( tz = None ) return f \"{dt.year}{dt.month:02}{dt.day:02}T{dt.hour:02}{dt.minute:02}{dt.second:02}\" year \u00b6 1 2 3 def year ( game : 'Game' ) -> 'str' View Source def year ( game : Game ) -> str : return str ( game . metadata . date . year ) Classes \u00b6 ParseError \u00b6 1 2 3 4 5 class ParseError ( message , filename = None , pos = None ) View Source class ParseError ( IOError ) : def __init__ ( self , message , filename = None , pos = None ) : super (). __init__ ( message ) self . filename = filename self . pos = pos def __str__ ( self ) : return ' Parse error ( % s % s ) : % s ' % ( self . filename or '?' , ' @0 x % x ' % self . pos if self . pos else '?' , super (). __str__ ()) Ancestors (in MRO) \u00b6 builtins.OSError builtins.Exception builtins.BaseException Class variables \u00b6 1 args 1 characters_written 1 errno 1 filename 1 filename2 1 strerror Methods \u00b6 with_traceback \u00b6 1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Index"},{"location":"reference/treefrog/parse/#module-treefrogparse","text":"None None View Source from .parsers import day , hour , matchup , minute , month , second , stage , timestamp , year from .utils import ParseError , Parser __all__ = ( \"matchup\" , \"stage\" , \"timestamp\" , \"year\" , \"month\" , \"day\" , \"hour\" , \"minute\" , \"second\" , \"Parser\" , \"ParseError\" , )","title":"Module treefrog.parse"},{"location":"reference/treefrog/parse/#sub-modules","text":"treefrog.parse.parsers treefrog.parse.utils","title":"Sub-modules"},{"location":"reference/treefrog/parse/#variables","text":"1 Parser","title":"Variables"},{"location":"reference/treefrog/parse/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/parse/#day","text":"1 2 3 def day ( game : 'Game' ) -> 'str' View Source def day ( game : Game ) -> str : return str ( game . metadata . date . day )","title":"day"},{"location":"reference/treefrog/parse/#hour","text":"1 2 3 def hour ( game : 'Game' ) -> 'str' View Source def hour ( game : Game ) -> str : return str ( game . metadata . date . hour )","title":"hour"},{"location":"reference/treefrog/parse/#matchup","text":"1 2 3 def matchup ( game : 'Game' ) -> 'str' View Source def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \"{character_name(c1)} vs {character_name(c2)}\"","title":"matchup"},{"location":"reference/treefrog/parse/#minute","text":"1 2 3 def minute ( game : 'Game' ) -> 'str' View Source def minute ( game : Game ) -> str : return str ( game . metadata . date . minute )","title":"minute"},{"location":"reference/treefrog/parse/#month","text":"1 2 3 def month ( game : 'Game' ) -> 'str' View Source def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ]","title":"month"},{"location":"reference/treefrog/parse/#second","text":"1 2 3 def second ( game : 'Game' ) -> 'str' View Source def second ( game : Game ) -> str : return str ( game . metadata . date . second )","title":"second"},{"location":"reference/treefrog/parse/#stage","text":"1 2 3 def stage ( game : 'Game' ) -> 'str' View Source def stage ( game : Game ) -> str : return stage_name ( game . start . stage )","title":"stage"},{"location":"reference/treefrog/parse/#timestamp","text":"1 2 3 def timestamp ( game : 'Game' ) -> 'str' View Source def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ). astimezone ( tz = None ) return f \"{dt.year}{dt.month:02}{dt.day:02}T{dt.hour:02}{dt.minute:02}{dt.second:02}\"","title":"timestamp"},{"location":"reference/treefrog/parse/#year","text":"1 2 3 def year ( game : 'Game' ) -> 'str' View Source def year ( game : Game ) -> str : return str ( game . metadata . date . year )","title":"year"},{"location":"reference/treefrog/parse/#classes","text":"","title":"Classes"},{"location":"reference/treefrog/parse/#parseerror","text":"1 2 3 4 5 class ParseError ( message , filename = None , pos = None ) View Source class ParseError ( IOError ) : def __init__ ( self , message , filename = None , pos = None ) : super (). __init__ ( message ) self . filename = filename self . pos = pos def __str__ ( self ) : return ' Parse error ( % s % s ) : % s ' % ( self . filename or '?' , ' @0 x % x ' % self . pos if self . pos else '?' , super (). __str__ ())","title":"ParseError"},{"location":"reference/treefrog/parse/#ancestors-in-mro","text":"builtins.OSError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/treefrog/parse/#class-variables","text":"1 args 1 characters_written 1 errno 1 filename 1 filename2 1 strerror","title":"Class variables"},{"location":"reference/treefrog/parse/#methods","text":"","title":"Methods"},{"location":"reference/treefrog/parse/#with_traceback","text":"1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/treefrog/parse/parsers/","text":"Module treefrog.parse.parsers \u00b6 None None View Source from __future__ import annotations import calendar from datetime import timezone from slippi import Game from .utils import character_name , characters , stage_name def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \" { character_name ( c1 ) } vs { character_name ( c2 ) } \" def stage ( game : Game ) -> str : return stage_name ( game . start . stage ) def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ) . astimezone ( tz = None ) return f \" { dt . year }{ dt . month : 02 }{ dt . day : 02 } T { dt . hour : 02 }{ dt . minute : 02 }{ dt . second : 02 } \" def year ( game : Game ) -> str : return str ( game . metadata . date . year ) def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ] def day ( game : Game ) -> str : return str ( game . metadata . date . day ) def hour ( game : Game ) -> str : return str ( game . metadata . date . hour ) def minute ( game : Game ) -> str : return str ( game . metadata . date . minute ) def second ( game : Game ) -> str : return str ( game . metadata . date . second ) __all__ = \"matchup\" , \"stage\" , \"timestamp\" , \"year\" , \"month\" , \"day\" , \"hour\" , \"minute\" , \"second\" Functions \u00b6 day \u00b6 1 2 3 def day ( game : 'Game' ) -> 'str' View Source def day ( game : Game ) -> str : return str ( game . metadata . date . day ) hour \u00b6 1 2 3 def hour ( game : 'Game' ) -> 'str' View Source def hour ( game : Game ) -> str : return str ( game . metadata . date . hour ) matchup \u00b6 1 2 3 def matchup ( game : 'Game' ) -> 'str' View Source def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \"{character_name(c1)} vs {character_name(c2)}\" minute \u00b6 1 2 3 def minute ( game : 'Game' ) -> 'str' View Source def minute ( game : Game ) -> str : return str ( game . metadata . date . minute ) month \u00b6 1 2 3 def month ( game : 'Game' ) -> 'str' View Source def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ] second \u00b6 1 2 3 def second ( game : 'Game' ) -> 'str' View Source def second ( game : Game ) -> str : return str ( game . metadata . date . second ) stage \u00b6 1 2 3 def stage ( game : 'Game' ) -> 'str' View Source def stage ( game : Game ) -> str : return stage_name ( game . start . stage ) timestamp \u00b6 1 2 3 def timestamp ( game : 'Game' ) -> 'str' View Source def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ). astimezone ( tz = None ) return f \"{dt.year}{dt.month:02}{dt.day:02}T{dt.hour:02}{dt.minute:02}{dt.second:02}\" year \u00b6 1 2 3 def year ( game : 'Game' ) -> 'str' View Source def year ( game : Game ) -> str : return str ( game . metadata . date . year )","title":"Parsers"},{"location":"reference/treefrog/parse/parsers/#module-treefrogparseparsers","text":"None None View Source from __future__ import annotations import calendar from datetime import timezone from slippi import Game from .utils import character_name , characters , stage_name def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \" { character_name ( c1 ) } vs { character_name ( c2 ) } \" def stage ( game : Game ) -> str : return stage_name ( game . start . stage ) def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ) . astimezone ( tz = None ) return f \" { dt . year }{ dt . month : 02 }{ dt . day : 02 } T { dt . hour : 02 }{ dt . minute : 02 }{ dt . second : 02 } \" def year ( game : Game ) -> str : return str ( game . metadata . date . year ) def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ] def day ( game : Game ) -> str : return str ( game . metadata . date . day ) def hour ( game : Game ) -> str : return str ( game . metadata . date . hour ) def minute ( game : Game ) -> str : return str ( game . metadata . date . minute ) def second ( game : Game ) -> str : return str ( game . metadata . date . second ) __all__ = \"matchup\" , \"stage\" , \"timestamp\" , \"year\" , \"month\" , \"day\" , \"hour\" , \"minute\" , \"second\"","title":"Module treefrog.parse.parsers"},{"location":"reference/treefrog/parse/parsers/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/parse/parsers/#day","text":"1 2 3 def day ( game : 'Game' ) -> 'str' View Source def day ( game : Game ) -> str : return str ( game . metadata . date . day )","title":"day"},{"location":"reference/treefrog/parse/parsers/#hour","text":"1 2 3 def hour ( game : 'Game' ) -> 'str' View Source def hour ( game : Game ) -> str : return str ( game . metadata . date . hour )","title":"hour"},{"location":"reference/treefrog/parse/parsers/#matchup","text":"1 2 3 def matchup ( game : 'Game' ) -> 'str' View Source def matchup ( game : Game ) -> str : c1 , c2 = tuple ( characters ( game )) return f \"{character_name(c1)} vs {character_name(c2)}\"","title":"matchup"},{"location":"reference/treefrog/parse/parsers/#minute","text":"1 2 3 def minute ( game : 'Game' ) -> 'str' View Source def minute ( game : Game ) -> str : return str ( game . metadata . date . minute )","title":"minute"},{"location":"reference/treefrog/parse/parsers/#month","text":"1 2 3 def month ( game : 'Game' ) -> 'str' View Source def month ( game : Game ) -> str : return calendar . month_name [ game . metadata . date . month ]","title":"month"},{"location":"reference/treefrog/parse/parsers/#second","text":"1 2 3 def second ( game : 'Game' ) -> 'str' View Source def second ( game : Game ) -> str : return str ( game . metadata . date . second )","title":"second"},{"location":"reference/treefrog/parse/parsers/#stage","text":"1 2 3 def stage ( game : 'Game' ) -> 'str' View Source def stage ( game : Game ) -> str : return stage_name ( game . start . stage )","title":"stage"},{"location":"reference/treefrog/parse/parsers/#timestamp","text":"1 2 3 def timestamp ( game : 'Game' ) -> 'str' View Source def timestamp ( game : Game ) -> str : utc_dt = game . metadata . date dt = utc_dt . replace ( tzinfo = timezone . utc ). astimezone ( tz = None ) return f \"{dt.year}{dt.month:02}{dt.day:02}T{dt.hour:02}{dt.minute:02}{dt.second:02}\"","title":"timestamp"},{"location":"reference/treefrog/parse/parsers/#year","text":"1 2 3 def year ( game : 'Game' ) -> 'str' View Source def year ( game : Game ) -> str : return str ( game . metadata . date . year )","title":"year"},{"location":"reference/treefrog/parse/utils/","text":"Module treefrog.parse.utils \u00b6 None None View Source from concurrent.futures import ProcessPoolExecutor from pathlib import Path from typing import Callable , Generator , Optional , Sequence from slippi import Game from slippi.id import InGameCharacter , Stage from slippi.metadata import Metadata from slippi.parse import ParseError Parser = Callable [[ Game ], str ] def _game ( path : Path ) -> Optional [ Game ]: try : return Game ( path ) except ParseError : return None def games ( sources : Sequence [ Path ]) -> Generator [ Game , None , None ]: with ProcessPoolExecutor () as executor : for game in executor . map ( _game , sources ): yield game def ports ( game : Game ) -> Generator [ int , None , None ]: return ( p + 1 for p , player in enumerate ( game . metadata . players ) if player ) def most_used_character ( player : Metadata . Player ) -> InGameCharacter : return sorted ( player . characters . keys (), key = lambda c : player . characters [ c ])[ 0 ] def players ( game : Game ) -> Generator [ Metadata . Player , None , None ]: return ( game . metadata . players [ port - 1 ] for port in ports ( game )) def characters ( game : Game ) -> Generator [ InGameCharacter , None , None ]: return ( most_used_character ( player ) for player in players ( game )) def user ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ): if player . netplay . code == netplay_code : return player def opponent ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ): if player . netplay . code != netplay_code : return player def character_name ( character : InGameCharacter ) -> str : if character == InGameCharacter . DR_MARIO : return \"Dr. Mario\" if character == InGameCharacter . GAME_AND_WATCH : return \"Game & Watch\" if character in { InGameCharacter . POPO , InGameCharacter . NANA }: return \"Ice Climbers\" return character . name . replace ( \"_\" , \" \" ) . title () def stage_name ( stage : Stage ) -> str : if stage == Stage . FOUNTAIN_OF_DREAMS : return \"Fountain of Dreams\" if stage == Stage . YOSHIS_STORY : return \"Yoshi's Story\" return stage . name . replace ( \"_\" , \" \" ) . title () Variables \u00b6 1 Parser Functions \u00b6 character_name \u00b6 1 2 3 def character_name ( character : slippi . id . InGameCharacter ) -> str View Source def character_name ( character : InGameCharacter ) -> str : if character == InGameCharacter . DR_MARIO : return \"Dr. Mario\" if character == InGameCharacter . GAME_AND_WATCH : return \"Game & Watch\" if character in { InGameCharacter . POPO , InGameCharacter . NANA } : return \"Ice Climbers\" return character . name . replace ( \"_\" , \" \" ). title () characters \u00b6 1 2 3 def characters ( game : slippi . game . Game ) -> Generator [ slippi . id . InGameCharacter , NoneType , NoneType ] View Source def characters ( game : Game ) -> Generator [ InGameCharacter , None , None ] : return ( most_used_character ( player ) for player in players ( game )) games \u00b6 1 2 3 def games ( sources : Sequence [ pathlib . Path ] ) -> Generator [ slippi . game . Game , NoneType , NoneType ] View Source def games ( sources : Sequence [ Path ] ) -> Generator [ Game, None, None ] : with ProcessPoolExecutor () as executor : for game in executor . map ( _game , sources ) : yield game most_used_character \u00b6 1 2 3 def most_used_character ( player : slippi . metadata . Metadata . Player ) -> slippi . id . InGameCharacter View Source def most_used_character ( player : Metadata . Player ) -> InGameCharacter : return sorted ( player . characters . keys (), key = lambda c : player . characters [ c ] ) [ 0 ] opponent \u00b6 1 2 3 4 def opponent ( game : slippi . game . Game , netplay_code : str ) -> slippi . metadata . Metadata . Player View Source def opponent ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ) : if player . netplay . code != netplay_code : return player players \u00b6 1 2 3 def players ( game : slippi . game . Game ) -> Generator [ slippi . metadata . Metadata . Player , NoneType , NoneType ] View Source def players ( game : Game ) -> Generator [ Metadata . Player , None , None ] : return ( game . metadata . players [ port - 1 ] for port in ports ( game )) ports \u00b6 1 2 3 def ports ( game : slippi . game . Game ) -> Generator [ int , NoneType , NoneType ] View Source def ports ( game : Game ) -> Generator [ int , None , None ]: return ( p + 1 for p , player in enumerate ( game . metadata . players ) if player ) stage_name \u00b6 1 2 3 def stage_name ( stage : slippi . id . Stage ) -> str View Source def stage_name ( stage : Stage ) -> str : if stage == Stage . FOUNTAIN_OF_DREAMS : return \"Fountain of Dreams\" if stage == Stage . YOSHIS_STORY : return \"Yoshi' s Story \" return stage.name.replace(\" _ \", \" \").title() user \u00b6 1 2 3 4 def user ( game : slippi . game . Game , netplay_code : str ) -> slippi . metadata . Metadata . Player View Source def user ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ) : if player . netplay . code == netplay_code : return player","title":"Utils"},{"location":"reference/treefrog/parse/utils/#module-treefrogparseutils","text":"None None View Source from concurrent.futures import ProcessPoolExecutor from pathlib import Path from typing import Callable , Generator , Optional , Sequence from slippi import Game from slippi.id import InGameCharacter , Stage from slippi.metadata import Metadata from slippi.parse import ParseError Parser = Callable [[ Game ], str ] def _game ( path : Path ) -> Optional [ Game ]: try : return Game ( path ) except ParseError : return None def games ( sources : Sequence [ Path ]) -> Generator [ Game , None , None ]: with ProcessPoolExecutor () as executor : for game in executor . map ( _game , sources ): yield game def ports ( game : Game ) -> Generator [ int , None , None ]: return ( p + 1 for p , player in enumerate ( game . metadata . players ) if player ) def most_used_character ( player : Metadata . Player ) -> InGameCharacter : return sorted ( player . characters . keys (), key = lambda c : player . characters [ c ])[ 0 ] def players ( game : Game ) -> Generator [ Metadata . Player , None , None ]: return ( game . metadata . players [ port - 1 ] for port in ports ( game )) def characters ( game : Game ) -> Generator [ InGameCharacter , None , None ]: return ( most_used_character ( player ) for player in players ( game )) def user ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ): if player . netplay . code == netplay_code : return player def opponent ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ): if player . netplay . code != netplay_code : return player def character_name ( character : InGameCharacter ) -> str : if character == InGameCharacter . DR_MARIO : return \"Dr. Mario\" if character == InGameCharacter . GAME_AND_WATCH : return \"Game & Watch\" if character in { InGameCharacter . POPO , InGameCharacter . NANA }: return \"Ice Climbers\" return character . name . replace ( \"_\" , \" \" ) . title () def stage_name ( stage : Stage ) -> str : if stage == Stage . FOUNTAIN_OF_DREAMS : return \"Fountain of Dreams\" if stage == Stage . YOSHIS_STORY : return \"Yoshi's Story\" return stage . name . replace ( \"_\" , \" \" ) . title ()","title":"Module treefrog.parse.utils"},{"location":"reference/treefrog/parse/utils/#variables","text":"1 Parser","title":"Variables"},{"location":"reference/treefrog/parse/utils/#functions","text":"","title":"Functions"},{"location":"reference/treefrog/parse/utils/#character_name","text":"1 2 3 def character_name ( character : slippi . id . InGameCharacter ) -> str View Source def character_name ( character : InGameCharacter ) -> str : if character == InGameCharacter . DR_MARIO : return \"Dr. Mario\" if character == InGameCharacter . GAME_AND_WATCH : return \"Game & Watch\" if character in { InGameCharacter . POPO , InGameCharacter . NANA } : return \"Ice Climbers\" return character . name . replace ( \"_\" , \" \" ). title ()","title":"character_name"},{"location":"reference/treefrog/parse/utils/#characters","text":"1 2 3 def characters ( game : slippi . game . Game ) -> Generator [ slippi . id . InGameCharacter , NoneType , NoneType ] View Source def characters ( game : Game ) -> Generator [ InGameCharacter , None , None ] : return ( most_used_character ( player ) for player in players ( game ))","title":"characters"},{"location":"reference/treefrog/parse/utils/#games","text":"1 2 3 def games ( sources : Sequence [ pathlib . Path ] ) -> Generator [ slippi . game . Game , NoneType , NoneType ] View Source def games ( sources : Sequence [ Path ] ) -> Generator [ Game, None, None ] : with ProcessPoolExecutor () as executor : for game in executor . map ( _game , sources ) : yield game","title":"games"},{"location":"reference/treefrog/parse/utils/#most_used_character","text":"1 2 3 def most_used_character ( player : slippi . metadata . Metadata . Player ) -> slippi . id . InGameCharacter View Source def most_used_character ( player : Metadata . Player ) -> InGameCharacter : return sorted ( player . characters . keys (), key = lambda c : player . characters [ c ] ) [ 0 ]","title":"most_used_character"},{"location":"reference/treefrog/parse/utils/#opponent","text":"1 2 3 4 def opponent ( game : slippi . game . Game , netplay_code : str ) -> slippi . metadata . Metadata . Player View Source def opponent ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ) : if player . netplay . code != netplay_code : return player","title":"opponent"},{"location":"reference/treefrog/parse/utils/#players","text":"1 2 3 def players ( game : slippi . game . Game ) -> Generator [ slippi . metadata . Metadata . Player , NoneType , NoneType ] View Source def players ( game : Game ) -> Generator [ Metadata . Player , None , None ] : return ( game . metadata . players [ port - 1 ] for port in ports ( game ))","title":"players"},{"location":"reference/treefrog/parse/utils/#ports","text":"1 2 3 def ports ( game : slippi . game . Game ) -> Generator [ int , NoneType , NoneType ] View Source def ports ( game : Game ) -> Generator [ int , None , None ]: return ( p + 1 for p , player in enumerate ( game . metadata . players ) if player )","title":"ports"},{"location":"reference/treefrog/parse/utils/#stage_name","text":"1 2 3 def stage_name ( stage : slippi . id . Stage ) -> str View Source def stage_name ( stage : Stage ) -> str : if stage == Stage . FOUNTAIN_OF_DREAMS : return \"Fountain of Dreams\" if stage == Stage . YOSHIS_STORY : return \"Yoshi' s Story \" return stage.name.replace(\" _ \", \" \").title()","title":"stage_name"},{"location":"reference/treefrog/parse/utils/#user","text":"1 2 3 4 def user ( game : slippi . game . Game , netplay_code : str ) -> slippi . metadata . Metadata . Player View Source def user ( game : Game , netplay_code : str ) -> Metadata . Player : for player in players ( game ) : if player . netplay . code == netplay_code : return player","title":"user"}]}